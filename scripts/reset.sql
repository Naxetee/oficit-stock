DROP TRIGGER IF EXISTS trigger_actualizar_stock_movimiento ON "Movimiento";
DROP FUNCTION IF EXISTS actualizar_stock_movimiento();
DROP TRIGGER IF EXISTS trg_before_insert_pack ON "Pack";
DROP FUNCTION IF EXISTS before_insert_pack();
DROP TRIGGER IF EXISTS trg_before_insert_producto_simple ON "Producto_Simple";
DROP FUNCTION IF EXISTS before_insert_producto_simple();
DROP TRIGGER IF EXISTS trg_before_insert_producto_compuesto ON "Producto_Compuesto";
DROP FUNCTION IF EXISTS before_insert_producto_compuesto();

DROP TABLE IF EXISTS "Composicion_Prod_Compuesto" CASCADE;
DROP TABLE IF EXISTS "Composicion_Pack" CASCADE;
DROP TABLE IF EXISTS "Producto_Compuesto" CASCADE;
DROP TABLE IF EXISTS "Producto_Simple" CASCADE;
DROP TABLE IF EXISTS "Producto" CASCADE;
DROP TABLE IF EXISTS "Pack" CASCADE;
DROP TABLE IF EXISTS "Articulo" CASCADE;
DROP TABLE IF EXISTS "Componente" CASCADE;
DROP TABLE IF EXISTS "Proveedor" CASCADE;
DROP TABLE IF EXISTS "Color" CASCADE;
DROP TABLE IF EXISTS "Familia" CASCADE;
DROP TABLE IF EXISTS "Stock" CASCADE;
DROP TABLE IF EXISTS "Movimiento" CASCADE;


-- Droping relationships
ALTER TABLE IF EXISTS "Componente" DROP CONSTRAINT IF EXISTS "Componente_id_proveedor_fkey";
ALTER TABLE IF EXISTS "Componente" DROP CONSTRAINT IF EXISTS "Componente_id_color_fkey";
ALTER TABLE IF EXISTS "Color" DROP CONSTRAINT IF EXISTS "Color_id_familia_fkey";
ALTER TABLE IF EXISTS "Articulo" DROP CONSTRAINT IF EXISTS "Articulo_id_familia_fkey";
ALTER TABLE IF EXISTS "Producto_Simple" DROP CONSTRAINT IF EXISTS "Producto_Simple_id_proveedor_fkey";
ALTER TABLE IF EXISTS "Producto_Simple" DROP CONSTRAINT IF EXISTS "Producto_Simple_id_color_fkey";
ALTER TABLE IF EXISTS "Composicion_Prod_Compuesto" DROP CONSTRAINT IF EXISTS "Composicion_Prod_Compuesto_id_producto_compuesto_fkey";
ALTER TABLE IF EXISTS "Composicion_Prod_Compuesto" DROP CONSTRAINT IF EXISTS "Composicion_Prod_Compuesto_id_componente_fkey";
ALTER TABLE IF EXISTS "Composicion_Pack" DROP CONSTRAINT IF EXISTS "Composicion_Pack_id_pack_fkey";
ALTER TABLE IF EXISTS "Composicion_Pack" DROP CONSTRAINT IF EXISTS "Composicion_Pack_id_producto_fkey";
ALTER TABLE IF EXISTS "Stock" DROP CONSTRAINT IF EXISTS "Stock_id_producto_simple_fkey";
ALTER TABLE IF EXISTS "Stock" DROP CONSTRAINT IF EXISTS "Stock_id_componente_fkey";
ALTER TABLE IF EXISTS "Movimiento" DROP CONSTRAINT IF EXISTS "Movimiento_id_stock_fkey";

-- Reset sequences for tables with GENERATED BY DEFAULT AS IDENTITY
ALTER SEQUENCE IF EXISTS "Componente_id_seq" RESTART WITH 1;
ALTER SEQUENCE IF EXISTS "Proveedor_id_seq" RESTART WITH 1;
ALTER SEQUENCE IF EXISTS "Color_id_seq" RESTART WITH 1;
ALTER SEQUENCE IF EXISTS "Familia_id_seq" RESTART WITH 1;
ALTER SEQUENCE IF EXISTS "Articulo_id_seq" RESTART WITH 1;
ALTER SEQUENCE IF EXISTS "Stock_id_seq" RESTART WITH 1;
ALTER SEQUENCE IF EXISTS "Movimiento_id_seq" RESTART WITH 1;

CREATE TABLE "Componente" (
	"id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
	"nombre" VARCHAR(255) NOT NULL UNIQUE,
	"descripcion" TEXT,
	"id_proveedor" INTEGER,
	"id_color" INTEGER,
	"created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	"updated_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY("id")
);

CREATE TABLE "Proveedor" (
	"id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
	"nombre" VARCHAR(127) NOT NULL UNIQUE,
	"telefono" VARCHAR(31),
	"email" VARCHAR(127),
	"direccion" VARCHAR(255),
	"activo" BOOLEAN DEFAULT False,
	"created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	"updated_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY("id")
);

CREATE TABLE "Color" (
	"id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
	"nombre" VARCHAR(31) NOT NULL UNIQUE,
	"hex" VARCHAR(7),
	"url_imagen" VARCHAR(511),
	"id_familia" INTEGER,
	"created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	"updated_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY("id")
);

CREATE TABLE "Familia" (
	"id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
	"nombre" VARCHAR(127) NOT NULL UNIQUE,
	"descripcion" TEXT,
	"created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	"updated_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY("id")
);

CREATE TABLE "Articulo" (
	"id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
	"nombre" VARCHAR(255),
	"descripcion" TEXT,
	"codigo_tienda" VARCHAR(31) UNIQUE,
	"id_familia" INTEGER,
	"activo" BOOLEAN DEFAULT False,
	"tipo" VARCHAR(255) NOT NULL CHECK(tipo IS NULL OR tipo IN ('simple', 'compuesto', 'pack')),
	"created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	"updated_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY("id")
);

CREATE TABLE "Producto" (
	PRIMARY KEY("id")
) INHERITS ("Articulo");

CREATE TABLE "Producto_Simple" (
	"id_proveedor" INTEGER,
	"id_color" INTEGER,
	PRIMARY KEY("id")
) INHERITS ("Producto");

CREATE TABLE "Producto_Compuesto" (
	PRIMARY KEY("id")
) INHERITS ("Producto");

CREATE TABLE "Composicion_Prod_Compuesto" (
	"id_producto_compuesto" INTEGER,
	"id_componente" INTEGER,
	"cantidad" INTEGER,
	PRIMARY KEY("id_producto_compuesto", "id_componente")
);

CREATE TABLE "Pack" (
	PRIMARY KEY("id")
) INHERITS ("Articulo");

CREATE TABLE "Composicion_Pack" (
	"id_pack" INTEGER NOT NULL,
	"id_producto" INTEGER NOT NULL,
	"cantidad" INTEGER NOT NULL DEFAULT 0,
	PRIMARY KEY("id_pack", "id_producto")
);

CREATE TABLE "Stock" (
	"id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
	"cantidad" INTEGER NOT NULL DEFAULT 0,
	"cantidad_minima" INTEGER NOT NULL DEFAULT 0,
	"ubicacion" VARCHAR(255),
	"tipo" VARCHAR(31) NOT NULL CHECK(tipo IN ('producto_simple', 'componente')),
	"id_componente" INTEGER,
	"id_producto_simple" INTEGER,
	"created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	"updated_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY("id"),
	CHECK (
		(tipo = 'componente' AND id_componente IS NOT NULL AND id_producto_simple IS NULL)
		OR
		(tipo = 'producto_simple' AND id_producto_simple IS NOT NULL AND id_componente IS NULL)
	)
);

CREATE TABLE "Movimiento" (
	"id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
	"tipo" VARCHAR(31) NOT NULL CHECK(tipo IN ('entrada', 'salida')),
	"cantidad" INTEGER NOT NULL,
	"descripcion" TEXT,
	"id_producto_simple" INTEGER,
	"id_componente" INTEGER,
	"created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	"updated_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY("id"),
	CHECK (
		(id_producto_simple IS NOT NULL AND id_componente IS NULL)
		OR
		(id_componente IS NOT NULL AND id_producto_simple IS NULL)
	)
);

ALTER TABLE "Componente"
ADD FOREIGN KEY("id_proveedor") REFERENCES "Proveedor"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Componente"
ADD FOREIGN KEY("id_color") REFERENCES "Color"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Color"
ADD FOREIGN KEY("id_familia") REFERENCES "Familia"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Articulo"
ADD FOREIGN KEY("id_familia") REFERENCES "Familia"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Producto_Simple"
ADD FOREIGN KEY("id_proveedor") REFERENCES "Proveedor"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Producto_Simple"
ADD FOREIGN KEY("id_color") REFERENCES "Color"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Composicion_Prod_Compuesto"
ADD FOREIGN KEY("id_producto_compuesto") REFERENCES "Producto_Compuesto"("id")
ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE "Composicion_Prod_Compuesto"
ADD FOREIGN KEY("id_componente") REFERENCES "Componente"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Composicion_Pack"
ADD FOREIGN KEY("id_pack") REFERENCES "Pack"("id")
ON UPDATE CASCADE ON DELETE CASCADE;
ALTER TABLE "Composicion_Pack"
ADD FOREIGN KEY("id_producto") REFERENCES "Producto"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Stock"
ADD FOREIGN KEY("id_producto_simple") REFERENCES "Producto_Simple"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Stock"
ADD FOREIGN KEY("id_componente") REFERENCES "Componente"("id")
ON UPDATE CASCADE ON DELETE RESTRICT;
ALTER TABLE "Movimiento"
ADD FOREIGN KEY("id_producto_simple") REFERENCES "Producto_Simple"("id")
ON UPDATE CASCADE ON DELETE NO ACTION;
ALTER TABLE "Movimiento"
ADD FOREIGN KEY("id_componente") REFERENCES "Componente"("id")
ON UPDATE CASCADE ON DELETE NO ACTION;



-- Trigger para actualizar el stock al insertar un movimiento
CREATE OR REPLACE FUNCTION actualizar_stock_movimiento()
RETURNS TRIGGER AS $$
DECLARE
	cantidad_actual INTEGER;
	stock_id INTEGER;
BEGIN
	IF NEW.id_producto_simple IS NOT NULL THEN
		SELECT id, cantidad INTO stock_id, cantidad_actual FROM "Stock"
		WHERE id_producto_simple = NEW.id_producto_simple AND id_componente IS NULL;
	ELSIF NEW.id_componente IS NOT NULL THEN
		SELECT id, cantidad INTO stock_id, cantidad_actual FROM "Stock"
		WHERE id_componente = NEW.id_componente AND id_producto_simple IS NULL;
	ELSE
		RAISE EXCEPTION 'Debe especificar id_producto_simple o id_componente en el movimiento.';
	END IF;

	IF NEW.tipo = 'salida' THEN
		IF cantidad_actual < NEW.cantidad THEN
			RAISE EXCEPTION 'No hay suficiente stock (id: %) para la salida. Stock actual: %, solicitado: %', stock_id, cantidad_actual, NEW.cantidad;
		END IF;
		UPDATE "Stock"
		SET cantidad = cantidad_actual - NEW.cantidad,
			updated_at = CURRENT_TIMESTAMP
		WHERE id = stock_id;
	ELSIF NEW.tipo = 'entrada' THEN
		UPDATE "Stock"
		SET cantidad = cantidad + NEW.cantidad,
			updated_at = CURRENT_TIMESTAMP
		WHERE id = stock_id;
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_actualizar_stock_movimiento
BEFORE INSERT ON "Movimiento"
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_movimiento();

-- Funcion y trigger para deshacer movimientos
CREATE OR REPLACE FUNCTION deshacer_movimiento()
RETURNS TRIGGER AS $$
DECLARE
	stock_id INTEGER;
	cantidad_actual INTEGER;
BEGIN
	IF OLD.id_producto_simple IS NOT NULL THEN
		SELECT id, cantidad INTO stock_id, cantidad_actual FROM "Stock"
		WHERE id_producto_simple = OLD.id_producto_simple AND id_componente IS NULL;
	ELSIF OLD.id_componente IS NOT NULL THEN
		SELECT id, cantidad INTO stock_id, cantidad_actual FROM "Stock"
		WHERE id_componente = OLD.id_componente AND id_producto_simple IS NULL;
	ELSE
		RAISE EXCEPTION 'Debe especificar id_producto_simple o id_componente en el movimiento.';
	END IF;
	IF OLD.tipo = 'salida' THEN
		UPDATE "Stock"
		SET cantidad = cantidad_actual + OLD.cantidad,
			updated_at = CURRENT_TIMESTAMP
		WHERE id = stock_id;
	ELSIF OLD.tipo = 'entrada' THEN
		IF cantidad_actual < OLD.cantidad THEN
			RAISE EXCEPTION 'No hay suficiente stock (id: %) para deshacer la entrada de stock.', stock_id;
		END IF;
		UPDATE "Stock"
		SET cantidad = cantidad_actual - OLD.cantidad,
			updated_at = CURRENT_TIMESTAMP
		WHERE id = stock_id;
	END IF;
	RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_deshacer_movimiento
AFTER DELETE ON "Movimiento"
FOR EACH ROW
EXECUTE FUNCTION deshacer_movimiento();
		

-- Función y trigger para Pack
CREATE OR REPLACE FUNCTION before_insert_pack()
RETURNS TRIGGER AS $$
DECLARE
    new_id INTEGER;
BEGIN
    IF NEW.id IS NULL THEN
        INSERT INTO "Articulo" ("nombre", "descripcion", "codigo_tienda", "id_familia", "activo", "tipo", "created_at", "updated_at")
        VALUES (NEW.nombre, NEW.descripcion, NEW.codigo_tienda, NEW.id_familia, NEW.activo, NEW.tipo, NEW.created_at, NEW.updated_at)
        RETURNING id INTO new_id;
        NEW.id := new_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_insert_pack
BEFORE INSERT ON "Pack"
FOR EACH ROW
EXECUTE FUNCTION before_insert_pack();

-- Función y trigger para Producto_Simple
CREATE OR REPLACE FUNCTION before_insert_producto_simple()
RETURNS TRIGGER AS $$
DECLARE
    new_id INTEGER;
BEGIN
    IF NEW.id IS NULL THEN
        -- Insertar en Articulo y obtener el id
        INSERT INTO "Articulo" ("nombre", "descripcion", "codigo_tienda", "id_familia", "activo", "tipo", "created_at", "updated_at")
        VALUES (NEW.nombre, NEW.descripcion, NEW.codigo_tienda, NEW.id_familia, NEW.activo, NEW.tipo, NEW.created_at, NEW.updated_at)
        RETURNING id INTO new_id;
        -- Insertar en Producto usando el mismo id
		INSERT INTO "Producto" (id, nombre, descripcion, codigo_tienda, id_familia, activo, tipo, created_at, updated_at)
		VALUES (new_id, NEW.nombre, NEW.descripcion, NEW.codigo_tienda, NEW.id_familia, NEW.activo, NEW.tipo, NEW.created_at, NEW.updated_at);
        NEW.id := new_id;
    ELSE
        -- Si el id ya existe, asegúrate de que exista en Producto
        INSERT INTO "Producto" (id, nombre, descripcion, codigo_tienda, id_familia, activo, tipo, created_at, updated_at)
		VALUES (new_id, NEW.nombre, NEW.descripcion, NEW.codigo_tienda, NEW.id_familia, NEW.activo, NEW.tipo, NEW.created_at, NEW.updated_at)
		ON CONFLICT (id) DO NOTHING; -- Asegura que no se duplique el id
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_insert_producto_simple
BEFORE INSERT ON "Producto_Simple"
FOR EACH ROW
EXECUTE FUNCTION before_insert_producto_simple();

-- Función y trigger para Producto_Compuesto
CREATE OR REPLACE FUNCTION before_insert_producto_compuesto()
RETURNS TRIGGER AS $$
DECLARE
    new_id INTEGER;
BEGIN
    IF NEW.id IS NULL THEN
        -- Insertar en Articulo y obtener el id
        INSERT INTO "Articulo" ("nombre", "descripcion", "codigo_tienda", "id_familia", "activo", "tipo", "created_at", "updated_at")
        VALUES (NEW.nombre, NEW.descripcion, NEW.codigo_tienda, NEW.id_familia, NEW.activo, NEW.tipo, NEW.created_at, NEW.updated_at)
        RETURNING id INTO new_id;
        -- Insertar en Producto usando el mismo id
        INSERT INTO "Producto" (id, nombre, descripcion, codigo_tienda, id_familia, activo, tipo, created_at, updated_at)
		VALUES (new_id, NEW.nombre, NEW.descripcion, NEW.codigo_tienda, NEW.id_familia, NEW.activo, NEW.tipo, NEW.created_at, NEW.updated_at);
        NEW.id := new_id;
    ELSE
        -- Si el id ya existe, asegúrate de que exista en Producto
        INSERT INTO "Producto" (id, nombre, descripcion, codigo_tienda, id_familia, activo, tipo, created_at, updated_at)
		VALUES (new_id, NEW.nombre, NEW.descripcion, NEW.codigo_tienda, NEW.id_familia, NEW.activo, NEW.tipo, NEW.created_at, NEW.updated_at)
		ON CONFLICT (id) DO NOTHING; -- Asegura que no se duplique el id
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_insert_producto_compuesto
BEFORE INSERT ON "Producto_Compuesto"
FOR EACH ROW
EXECUTE FUNCTION before_insert_producto_compuesto();